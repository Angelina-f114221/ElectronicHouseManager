package org.example.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.NoArgsConstructor;
import lombok.Setter;
import lombok.ToString;

import java.util.Set;

/*
представлява ентити клас, който ще отговаря за таблица в базата и за моделите на данните ни. За да може класа компания да отговаря за таблица, трябва да бъде означен с entity анотация. ентити моделът служи за определяне на структурата на таблицата и за манипулиране на данните. първичният ключ трябва да се анотира изрично, иначе ще има грешка. тази entity анотация идва от jakarta и persistence подмодула. това е технологичен компонент, който осигурява да се ползват анотации за връзката между обектния и релационния модел и след това Hibernate работи с тях.
 */
@Entity
@Table(name = "companies")
@Getter
@Setter
@NoArgsConstructor
// toString методът включва само специфичните данни, без тези, които идват по наследство. обаче base entity включва първичния ключ. Тоест, трябва да може да бъде извикан в наследника и базовия toString метод, за да виждам цялата информация за обекта.
@ToString(callSuper=true)
public class Company extends BaseEntity {
    // анотирам ID-то, което също е от Jakarta
    // При генериране на записи, id-тата на една таблица са независими от тези на друга. позволява ни да имаме auto increment при code first подхода.
   private String name;

   @OneToMany(mappedBy = "company")
   @ToString.Exclude
    private Set<Building> buildings;

    // OneToMany mappedBy company означава, че имаме водеща страна на връзката, която е там, където е външният ключ. служителят работи точно в една компания. имам колекция, защото компанията трябва да пази много служители. задължително в колекцията се използва сет, защото сега сме в company страната, а от другата страна са служителите. те се различават по уникален начин, така че колекцията трябва да има вградения механизъм да ги различава по естествен начин. това е връзка със специфичен брой елементи от двете страни. имаме one company - many employees и many-to-one от страна на служителя. външният ключ, идващ от компанията, ще бъде в employee. Тази анотация/връзка е част от jakarta persistence layer. по този начин казвам, че employee знае за company и company знае за employee.
    // Ако използвам колекция (to-many връзка), се зареждат лейзи свързаните данни - преди да ги поискам, не се зареждат. to-one връзката е коренно различна, там се зареждат eager свързаните данни - дори да не искам, компанията ще бъде заредена заедно със служителите.
    @OneToMany(mappedBy = "company")
    /*
    състоянието на обекта company с извикването на супертустринга ще включи по подразбиране и това поле, което е сета от служители, за да може да направя връзката от тип one-to-many company employee. тук съм сложила една анотация, която изключва колекцията, защото в противен случай ще се хвърли exception, който е свързан със зареждането на тези данни при отделните relationships (тези данни не могат да бъдат заредени). въпреки че на практика може да няма нужда от тях. През entity модела тези данни и неговият тустринг метод се опитва да хване колекцията, а няма данни за служителя, свързан с тази компания. Това е класическа грешка, която се казва lazy initialization exception. искам данните да бъдат зареждани. Това не е грешно имплементирано.
    */
    @ToString.Exclude
    private Set<Employee> employees;
}
