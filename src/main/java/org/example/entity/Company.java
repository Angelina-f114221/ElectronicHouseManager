package org.example.entity;

import jakarta.persistence.*;
import lombok.Getter;
import lombok.Setter;
import lombok.ToString;

import java.util.Set;

/*
представлява ентити клас, който ще отговаря за таблица в базата и за моделите на данните ни. За да може класа компания да отговаря за таблица, трябва да бъде означен с entity анотация. ентити моделът служи за определяне на структурата на таблицата и за манипулиране на данните. първичният ключ трябва да се анотира изрично, иначе ще има грешка. тази entity анотация идва от jakarta и persistence подмодула. това е технологичен компонент, който осигурява да се ползват анотации за връзката между обектния и релационния модел и след това Hibernate работи с тях.
 */
@Entity
@Getter
@Setter
// toString методът включва само специфичните данни, без тези, които идват по наследство. обаче base entity включва първичния ключ. Тоест, трябва да може да бъде извикан в наследника и базовия toString метод, за да виждам цялата информация за обекта.
@ToString(callSuper=true)
public class Company extends BaseEntity {
    // анотирам ID-то, което също е от Jakarta
    // При генериране на записи, id-тата на една таблица са независими от тези на друга. позволява ни да имаме auto increment при code first подхода.
   private String name;

   @OneToMany(mappedBy = "company")
    private Set<Building> buildings;

    // OneToMany mappedBy company означава, че имаме водеща страна на връзката, която е там, където е външният ключ. служителят работи точно в една компания. имам колекция, защото компанията трябва да пази много служители. задължително в колекцията се използва сет, защото сега сме в company страната, а от другата страна са служителите. те се различават по уникален начин, така че колекцията трябва да има вградения механизъм да ги различава по естествен начин. това е връзка със специфичен брой елементи от двете страни. имаме one company - many employees и many-to-one от страна на служителя. външният ключ, идващ от компанията, ще бъде в employee. Тази анотация/връзка е част от jakarta persistence layer. по този начин казвам, че employee знае за company и company знае за employee.
    // Ако използвам колекция (to-many връзка), се зареждат лейзи свързаните данни - преди да ги поискам, не се зареждат. to-one връзката е коренно различна, там се зареждат eager свързаните данни - дори да не искам, компанията ще бъде заредена заедно със служителите.
    @OneToMany(mappedBy = "company")
    private Set<Employee> employees;
}
